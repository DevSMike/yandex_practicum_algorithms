package pricticum_structures.sprint3.final_tasks;

/*

yandex contest: https://contest.yandex.ru/contest/23815/run-report/123938046/

Был дан массив, который отсортирован по возрастанию, но был сдвиг. Таким образом, нужно было
реализовать бинарный поиск в нужной части массива.

-- ПРИНЦИП РАБОТЫ АЛГОРИТМА --
Рассчитывается центральный индекс. Если arr[mid] равен искомому, то возвращаем этот элемент.
Далее выбираем половину массива, в которой будем производить поиск. Смотрим, если arr[left] <= arr[mid],
то первая часть массива отсортирована по возрастанию. Начнем поиск в этой части: если искомый k меньше,
чем arr[mid], но при этом больше arr[left], тогда сужаем диапазон до [left, mid -1], иначе сужаем до
[mid + 1, right]. Если элемент в другой половине, то проверяем: если элемент больше, чем arr[mid] и при
этом меньше, чем arr[right], то сужаем диапазон до [mid+ 1, right], иначе сужаем до [left, mid - 1]


-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Так как массив был отсортирован по возрастанию, а потом был сдвиг, мы утверждаем, что есть отсортированные
по возрастанию части массива. Тогда мы можем найти элемент за O(logN), где N - количество элементов.
Нужно просто корректно выбрать половину для сравнения, правильно производить сужение границ поиска.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Сложность алгоритма равна временной сложности бинарного поиска - O(logN), где N - количество элементов
массива

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Функция всегда создает два указателя: left и right, не зависимо от размера массива
-> пространственная сложность алгоритма: O(1).
 */
public class Solution {

    public static int brokenSearch(int[] arr, int k) {
        int left = 0;
        int right = arr.length - 1;

        while (left <= right) {
            int mid = (right + left) / 2;
            if (arr[mid] == k) {
                return mid;
            }
            //если элемент находится в первой отсортированной части массива
            if (arr[left] <= arr[mid]) {
                if (arr[mid] > k && arr[left] <= k) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
                // элемент находится во второй отсортированной части
            } else {
                if (arr[mid] < k && arr[right] >= k) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
        }
        return -1;
    }

    private static void test() {
        int[] arr = {19, 21, 100, 101, 1, 4, 5, 7, 12};
        assert 6 == brokenSearch(arr, 5);
    }
}
